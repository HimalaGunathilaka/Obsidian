![[Pasted image 20250601161644.png]]

---
![[Pasted image 20250601161659.png]]

---
![[Pasted image 20250601161709.png]]

---
![[Pasted image 20250601161720.png]]

---
![[Pasted image 20250601161731.png]]

---
>Code used
``` python
import numpy as np
from scipy.linalg import qr

def qr_algorithm(A, k_max):
    """
    Implements the QR algorithm for eigenvalue computation

    Parameters:
        A (ndarray): Input matrix
        k_max (int): Number of iterations to perform

    Returns:
        List of (A_k, Q_k, R_k) tuples for each iteration
        Final matrix after k iterations (A_k)
    """
    A_current = A.copy()
    results = []

    print(f"Initial matrix A_0:")
    print(np.round(A_current, 2))
    print("-" * 50)

    for k in range(k_max):
        # QR decomposition of current A_k
        Q_k, R_k = qr(A_current)

        # Next iteration: A_{k+1} = R_k * Q_k
        A_next = R_k @ Q_k

        # Store results
        results.append((A_current.copy(), Q_k.copy(), R_k.copy()))

        # Print results for this iteration
        print(f"Iteration k = {k + 1}:")
        print(f"A_{k}:")
        print(np.round(A_current, 2))

        print(f"\nQ_{k}:")
        print(np.round(Q_k, 2))

        print(f"\nR_{k}:")
        print(np.round(R_k, 2))

        print(f"\nA_{k+1} = R_{k} * Q_{k}:")
        print(np.round(A_next, 2))

        print(f"\nDiagonal elements of A_{k+1}: {np.round(np.diag(A_next), 2)}")
        print("-" * 50)

        # Update A for next iteration
        A_current = A_next

    return results, A_current


def calculate_eigenvalues(A):
    """Calculate the actual eigenvalues of matrix A"""
    eigenvals = np.linalg.eigvals(A)
    return np.sort(eigenvals)[::-1]  # Sort in descending order


# Define the given matrix
A = np.array([
    [1, 0, 0],
    [1, 2, 1],
    [1, 1, 2]
], dtype=float)

print("QR Algorithm Implementation")
print("=" * 60)
print("Given matrix A:")
print(np.round(A, 2))
print("\n")

# Get number of iterations from user
try:
    k = int(input("Enter the number of iterations k: "))

    # Run QR algorithm
    results, final_A = qr_algorithm(A, k)

    # Calculate actual eigenvalues
    true_eigenvals = calculate_eigenvalues(A)

    print("\nFINAL RESULTS:")
    print("=" * 60)
    print(f"After {k} iterations:")
    print(f"Final A_{k}:")
    print(np.round(final_A, 2))

    print(f"\nDiagonal elements (approximated eigenvalues): {np.round(np.diag(final_A), 2)}")
    print(f"True eigenvalues: {np.round(true_eigenvals, 2)}")

    print(f"\nError in eigenvalue approximation:")
    diagonal_elements = np.diag(final_A)
    for i, (approx, true_val) in enumerate(zip(diagonal_elements, true_eigenvals)):
        error = abs(approx - true_val)
        print(f" Î»_{i+1}: {approx:.2f} vs {true_val:.2f}, error = {error:.2f}")

except ValueError:
    print("Please enter a valid integer for the number of iterations.")
except KeyboardInterrupt:
    print("\nOperation interrupted by user.")

```
---
>Diagonal value output

| Iteration k | Diagonal           |
| ----------- | ------------------ |
| 0           | [3.00, 1.00, 1.00] |
| 1           | [3.18, 0.87, 0.95] |
| 2           | [3.07, 0.95, 0.98] |
| 3           | [3.02, 0.98, 0.99] |
| 4           | [3.01, 0.99, 1.00] |
| 5           | [3.00, 1.00, 1.00] |
| 6           | [3.00, 1.00, 1.00] |
| 7           | [3.00, 1.00, 1.00] |
